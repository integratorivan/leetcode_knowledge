[Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/);

```javascript
var twoSum = function(numbers, target) {
    let left = 0;
    let right = numbers.length - 1;

    while (left < right) {
        const resultTarget = numbers[left] + numbers[right];

        if (resultTarget === target) {
            return [left+1, right+1]
        }

        if (resultTarget < target) {
            left++;
        } else {
            right--;
        }

    }
};
```

	1.	Сначала ты устанавливаешь два указателя: `left` в начале массива и `right` в конце массива.
	2.	Затем ты запускаешь цикл, который продолжается, пока `left` меньше `right`.
	3.	Внутри цикла, ты суммируешь числа, на которые указывают `left` и `right`, и сравниваешь с полученным целевым числом (`target`)
	4.	Если эта сумма равна целевому числу, ты останавливаешься и возвращаешь индексы `left+1` и `right+1` ( т.к. индексация должна начинаться с 1, а не с 0, как в JavaScript).
	5.	Если сумма меньше целевого числа, тебе нужна большая сумма и ты увеличиваешь `left` на 1 (т.к. массив отсортирован в неубывающем порядке, следующее число на позиции `left` будет больше текущего).
	6.	Если сумма больше целевого числа, тебе нужна меньшая сумма и ты уменьшаешь `right` на 1 (т.к. следующее число на позиции `right` будет меньше текущего).

    **Что касается сложности:**

	1.	Временная сложность этого алгоритма равна `O(n)`, где n — это количество элементов в массиве. Временная сложность `O(n)` означает, что время выполнения алгоритма прямо пропорционально количеству элементов.
	2.	Пространственная сложность равна `O(1)`, что означает использование постоянного объема памяти, независимо от размера входного массива. Такой подход является идеальным для больших наборов данных.