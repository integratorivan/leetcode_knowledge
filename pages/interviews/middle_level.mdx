## Расскажите о пирамиде тестирования.

    **Пирамида тестирования** - это концепция организации автоматизированных тестов, которая представляет собой модель, где тесты делятся на три уровня:
	1.	**Unit тесты**: На этом уровне находится большинство тестов. Они тестируют отдельные функции и методы кода. Они быстрые, их много, и они управляются разработчиками.
	2.	**Integration тесты**: Эти тесты обеспечивают тесную связь между разными модулями или слоями приложения. Их меньше, чем модульных или функциональных тестов, но они все еще важны для проверки того, что модули работают вместе, как предполагалось.
	3.	**End-to-End тесты**: На этом уровне тесты имитируют реальное поведение пользователя, работая с системой со стороны клиента. Несмотря на их высокую ценность, они дороги в разработке и поддержке, поэтому их рекомендуется делать относительно немного.

## Как запретить браузеру отдавать кэш на HTTP-запрос?

Отправка HTTP-параметра Cache-Control с директивой no-cache или no-store в ответе от сервера предложит браузеру не кешировать данный ответ.

Пример:

`Cache-Control: no-cache`

`Cache-Control: no-store`

Если вы хотите установить это на клиенте (например, в JavaScript при использовании fetch), вы можете использовать опцию cache: 'no-store'.

Пример:
`fetch(url, { cache: 'no-store' })...`

## Расскажите о паттернах Observer, Pub / Sub. Какая между ними разница?

**Observer (наблюдатель)** - это поведенческий паттерн проектирования, который создает механизм подписки, позволяющий одним объектам наблюдать и реагировать на события, происходящие в других объектах.

В этом паттерне существует **"субъект"** и множество **"наблюдателей"**. Субъект уведомляет наблюдателей о любых изменениях своего состояния. Паттерн Наблюдатель чаще всего используется в JavaScript, когда один объект должен наблюдать за изменениями в другом объекте.

Примеры использования Observer включают в себя `EventEmitter` в `Node.js` и `API` событий в браузере как часть модели DOM, в которой обработчики событий (наблюдатели) могут быть зарегистрированы для событий DOM.

```javascript
document.querySelector('button').addEventListener('click', () => {
  console.log('The button was clicked!');
});
```

**Publish/Subscribe** (Издатель/Подписчик), или **Pub/Sub**, является вариацией паттерна Observer. Он использует "топик" или "канал" как промежуточное звено между издателями и подписчиками. Этот дополнительный уровень абстракции означает, что издатели могут "публиковать" (отправлять) сообщения в определенные темы, а подписчики могут "подписываться" на прослушивание сообщений из этих тем.

**Pub/Sub** предлагает более гибкую организацию, поскольку издатели и подписчики не должны прямо друг друга знать. Это хорошо для расширяемости и модульности систем.

Пример Pub/Sub на клиенте - `API postMessage` в браузере, которое позволяет безопасно проводить асинхронное, междоменное общение. Более общий пример - работы с WebSocket, системы управления очередями сообщений типа RabbitMQ и MQTT.
```javascript
// Издатель
window.postMessage('Hello World!', 'http://example.org');
// Подписчик
window.addEventListener('message', event => {
  console.log(event.data); // logs 'Hello World!'
});
```
Существуют и другие JavaScript-библиотеки, такие как Redux и RxJS, которые используют эти паттерны в своих основных архитектурах.

## С какой целью может быть использован event listener события fetch self.addEventListener ( 'fetch', event => {})?

Этот прослушиватель события fetch может использоваться в сервис-воркерах (Service Workers) для перехвата и обслуживания HTTP-запросов, отправленных вашим веб-приложением.

Сервис-воркеры могут применяться для различных целей:
	1.	**Офлайн кэширование**: Сервис-воркеры могут кэшировать ответы на некоторые или все сетевые запросы, что позволяет приложению работать офлайн или на недостаточно стабильном соединении. Так при запросе ресурса сначала смотрится наличие этого ресурса в кэше, и если ресурс найден, то он возвращается из кэша.
	2.	**Перехват запросов**: C помощью fetch, сервис-воркер может изменять запросы или ответы. Это может быть полезно для преобразования запросов, вставки специфических заголовков или выполнения других операций на запрос/ответ.
	3.	**Push Notifications**: Сервис-воркеры могут прослушивать push-события из бэкенд-сервисов и даже активировать показ уведомлений при закрытом приложении.
	4.	**Background sync**: Сервис-воркер на основе событий может обслуживать запросы в фоновом режиме или запускать синхронизацию данных при появлении интернет-соединения.
	
Пример использования fetch в сервис-воркере:
```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        if (response) {
          // возвращаем из кэша, если найдено
          return response;
        }
        // если нет в кэше, делаем запрос на сервер
        return fetch(event.request);
      })
  );
});
```

## Что такое Event loop?

- [ ] https://blog.yourcodereview.com/event-loop-layout-paintcomposite-i-stek-vyzovov/
- [ ] https://gist.github.com/paulirish/5d52fb081b3570c81e3a
- [ ] https://doka.guide/js/how-the-browser-creates-pages/
- [ ] https://habr.com/ru/companies/yandex/articles/468165/

Движок браузера выполняет JavaScript в одном потоке. Для потока выделяется область памяти — стэк, где хранятся фреймы (аргументы, локальные переменные) вызываемых функций.

Список событий, подлежащих обработке формируют очередь событий. Когда стек освобождается, движок может обрабатывать событие из очереди. Координирование этого процесса и происходит в event loop.

Это по сути бесконечный цикл, в котором выполняются многочисленные обработчики событий. Если очередь пустая — движок браузера ждет, когда поступит событие. Если непустая — первое в ней событие извлекается и его обработчик начинает выполняться. И так до бесконечности.

```javascript
function clicked() {
	console.log('clicked')
}

console.log('start')
console.log('start2')
```

1. У нас в Web Apis региструется наша функция и хранится там
2. в Call Stack у нас попадет 2 консоль лога, start, start2
3. Мы можем нажать на кнопку, чтоб сработал **clicked**, и это событие попадет в `callback queue`, или очередь, откуда это событие выполнится только если стэк будет пустым

### Micro и Macro tasks

Есть микротаски, есть макротаски. EventLoop берет в порядке важности эти задачи, **промисы это микротаски**, **таймауты это макротаски**. **В приоритете микротаски, они выполняются все, потом уже идут МАКРОтаски**

### Что такое МИКРОтаски?
- промисы
- queueMicrotask
- mutationObserver (метод для слежки за нодами в DOM

### Что такое МАКРОтаски?
- таймеры (timeout, interval)
- события (клик, например, загрузка картинок)
- браузерные штуки (рендер, input/ouput, короче все от копота браузера)

### Какие приоритеты у микро и макро тасок?
Выполнит сначала все микротаски, и если у нас очередь микротасок пуста, то берется ОДНА задача из макротасок